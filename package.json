{
  "name": "calva-backseat-driver",
  "displayName": "Calva Backseat Driver",
  "description": "Make CoPilot an Interactive Programmer, tools for VS Code CoPilot. Can also be run as an MCP server",
  "version": "0.0.18",
  "publisher": "betterthantomorrow",
  "author": {
    "name": "Better Than Tomorrow",
    "email": "pez@pezius.com"
  },
  "icon": "assets/extension-icon-128x128.png",
  "repository": {
    "type": "git",
    "url": "https://github.com/BetterThanTomorrow/calva-backseat-driver.git"
  },
  "engines": {
    "vscode": ">=1.96.2",
    "node": ">=20.18.0"
  },
  "enabledApiProposals": [
    "extensionRuntime"
  ],
  "categories": [
    "Programming Languages",
    "AI",
    "Other"
  ],
  "keywords": [
    "clojure",
    "clojurescript",
    "mcp",
    "model-context-protocol",
    "ai"
  ],
  "activationEvents": [
    "onLanguage:clojure"
  ],
  "main": "out/extension.js",
  "contributes": {
    "configuration": {
      "title": "Calva Backseat Driver",
      "properties": {
        "calva-backseat-driver.enableMcpReplEvaluation": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Enable the REPL evaluation tool through MCP.\n\n **⚠️ SECURITY WARNING**: _When enabled and you have also started the MCP server, any network client with access to the MCP server can execute arbitrary code in your REPL environment._ That said, CoPilot and other compliant MCP clients will default to a low-trust mode with confirmation before any evaluation.",
          "scope": "resource"
        },
        "calva-backseat-driver.autoStartMCPServer": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Automatically start the MCP server when the extension is activated.",
          "scope": "resource"
        },
        "calva-backseat-driver.mcpSocketServerPort": {
          "type": "number",
          "default": 1664,
          "markdownDescription": "Port to start the socket server on. Use `0` to let the server choose a high available port.",
          "scope": "resource"
        }
      }
    },
    "commands": [
      {
        "command": "calva-backseat-driver.startMcpServer",
        "category": "Calva Backseat Driver",
        "enablement": "!:calva-backseat-driver/started?",
        "title": "Start the MCP socket server"
      },
      {
        "command": "calva-backseat-driver.stopMcpServer",
        "category": "Calva Backseat Driver",
        "enablement": ":calva-backseat-driver/started?",
        "title": "Stop the MCP socket server"
      },
      {
        "command": "calva-backseat-driver.openLogFile",
        "category": "Calva Backseat Driver",
        "title": "Open log file"
      }
    ],
    "keybindings": [],
    "languageModelTools": [
      {
        "name": "evaluate_clojure_code",
        "tags": [
          "clojure",
          "repl",
          "needs-connected-repl",
          "interactive-programming",
          "repl-driven-development"
        ],
        "toolReferenceName": "evaluate",
        "displayName": "Evaluate Clojure Code",
        "modelDescription": "Evaluate code using Calva's REPL connection. Enables AI Interactive Programming. Use this to make sure your edits work as you advertise, before applying them. The REPL holds the truth!\n\nEvaluating ClojureScript code?\n* remember to use the `\"cljs\"` `replSessionKey`\n* The user namespace is probably/often `cljs.user`\n* `js-keys` is a handy function to explore JS objects with",
        "userDescription": "Evaluate Clojure or ClojureScript code in the connected REPL.",
        "canBeReferencedInPrompt": true,
        "icon": "$(terminal-bash)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Code to evaluate"
            },
            "namespace": {
              "type": "string",
              "description": "Fully qualified namespace in which to evaluate the code. E.g. if calling functions in a file you are reading, it is probably the namespace of that file that should be provided. If it is the first time you use a namespace, start with evaluating its ns-form in the `user` or `cljs.user` namespace (as appropriate)."
            },
            "replSessionKey": {
              "type": "string",
              "description": "The Calva REPL session to evaluate the code via. It should be:\n* `clj` for the Clojure REPL\n* `cljs` for the ClojureScript REPL",
              "enum": [
                "clj",
                "cljs",
                "cljc"
              ]
            }
          },
          "required": [
            "code",
            "namespace",
            "replSessionKey"
          ]
        }
      },
      {
        "name": "get_symbol_info",
        "tags": [
          "clojure",
          "documentation",
          "needs-connected-repl",
          "argument-list",
          "return-values",
          "side-effects"
        ],
        "toolReferenceName": "clojure-symbol",
        "displayName": "Clojure Symbol Info",
        "modelDescription": "Get detailed information about a Clojure symbol from the connected REPL.",
        "userDescription": "Look up documentation for a Clojure symbol.",
        "canBeReferencedInPrompt": true,
        "icon": "$(tag)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clojureSymbol": {
              "type": "string",
              "description": "The symbol to look up info for"
            },
            "namespace": {
              "type": "string",
              "description": "Fully qualified namespace in which to evaluate the code. E.g. if calling functions in a file you are reading, it is probably the namespace of that file that should be provided."
            },
            "replSessionKey": {
              "type": "string",
              "description": "The Calva REPL session to evaluate the code in. For Clojure, ClojureScript, and Common, respectively. Often the same as the extension of the file you are working with. One of `clj`, `cljs`, or `cljc`.",
              "enum": [
                "clj",
                "cljs",
                "cljc"
              ]
            }
          },
          "required": [
            "clojureSymbol",
            "namespace",
            "replSessionKey"
          ]
        }
      },
      {
        "name": "get_clojuredocs_info",
        "tags": [
          "clojure",
          "clojure-core",
          "needs-connected-repl",
          "examples",
          "see-also",
          "documentation"
        ],
        "toolReferenceName": "clojuredocs",
        "displayName": "clojuredocs.org Lookup",
        "modelDescription": "Look up information, examples, see also:s, and more about a Clojure Core symbol from clojuredocs.org.",
        "userDescription": "Get examples and usage from clojuredocs.org",
        "canBeReferencedInPrompt": true,
        "icon": "$(globe)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clojureSymbol": {
              "type": "string",
              "description": "The symbol to look up on clojuredocs.org"
            }
          },
          "required": [
            "clojureSymbol"
          ]
        }
      },
      {
        "name": "get_repl_output_log",
        "tags": [
          "clojure",
          "repl",
          "evaluation-results",
          "stdout",
          "stderr"
        ],
        "toolReferenceName": "calva-output",
        "displayName": "Calva REPL Output Log",
        "modelDescription": "Get REPL output messages from  Calva output window. Returns REPL output since `since-line`. Start with since-line=0 and use the last line number from previous output for subsequent calls. This is your window into the running application. Invoke it often as files are edited and/or you evaluate code.",
        "userDescription": "Read Calva's REPL output log",
        "canBeReferencedInPrompt": true,
        "icon": "$(list-ordered)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sinceLine": {
              "type": "integer",
              "description": "Output line-number after which you want output. Use `0` for your first request of output."
            }
          },
          "required": [
            "sinceLine"
          ]
        }
      },
      {
        "name": "balance_brackets",
        "tags": [
          "clojure",
          "parinfer",
          "brackets",
          "balance",
          "structural-editing"
        ],
        "toolReferenceName": "balance-brackets",
        "displayName": "Bracket Balancer",
        "modelDescription": "This tool AUTHORITATIVELY balances brackets in Clojure code. Always follow these steps when using it:\n\n1. Pass the COMPLETE content of the file or would-be file without any modifications\n2. Use the EXACT output from this tool to replace the ENTIRE file content\n3. NEVER modify the tool's output or analyze its changes",
        "userDescription": "Balance brackets in Clojure code",
        "canBeReferencedInPrompt": true,
        "icon": "$(bracket-error)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The COMPLETE text of the file needing bracket balancing. Do not modify this text in any way before passing it to the tool."
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "replace_top_level_form",
        "tags": [
          "clojure",
          "editing",
          "structural-editing",
          "parinfer"
        ],
        "toolReferenceName": "replace-top-level-form",
        "displayName": "Edit: Replace Top Level Form",
        "modelDescription": "# Editing CLojure files\n\nEven as an interactive programmer, now and then you do edit files. The most important things:\n\n1. **Before any editing: First always read the whole file you are about to edit.** Instead of chunked reading, **read it in one go**.\n2. Always check with the problem tool what the current linting state is\n3. Check with the problem tool after each edit\n4. Always be alert to when the bracket balance is off, and see [When the bracket balance is off](#when-the-bracket-balance-is-off) if it is.\n\nThe specific process look different depending on if you are creating files, adding functions, or editing existing functions.\n\n## Creating Clojure files\n\nUse the `create_file` tool to create files with empty content `\"\"`.\n\n### Clojure Namespace and Filename Convention:\n\n**Important**: In Clojure,  namespace names use kebab-case while filenames use snake_case. For example:\n- Namespace: `my.project.multi-word-namespace`\n- Filename: `my/project/multi_word_namespace.clj(s|c)`\n\nAlways convert dashes in namespace names to underscores in the corresponding filename.\n\n### Create empty files, then add content\n\nFor you to create files and add content safely/predictably, follow this process:\n\n1. **Always create empty files first** - Use `create_file` with empty content `\"\"`\n2. Read the content of the file created (default content may have been added)\n3. **Use structural editing tools** to edit the file\n\n## Important about the Structural Editing Tools\n\nUse the structural editing tools for Clojure forms/s-expressions.\n\n* Use `insert_top_level_form` to add new forms to a file\n* Use `replace_top_level_form` to modify existing forms\n* Make use of the diagnostics info returned\n* **Rich Comment Forms/RCF**: Calva treats forms immediately enclosed within `(comment <like this>)` as top level forms, making them valid targets for the top_level_form editing tools.\n\nThe structural editing tools attempt to automatically balance brackets before applying edits.\n\n### `replace_top_level_form`\n* Target top level forms by their starting, 1-based, line number\n* **Important**: This tool is **only** for replacing top level Clojure one form/s-expression with another form/s-expression\n  * For editing line comments (`; ...` which are not structural), use your built in edit tools\n\n### `insert_top_level_form`\n* Always target the top level of the code\n* Use 1-based, line numbers\n* **Important**: This tool is **only** for inserting Clojure forms/s-expressions, one at a time\n  * For inserting line comments (`; ...` which are not structural), use your built in edit tool\n\n## Structural editing process\n\nFollow this process for making safe and working updates:\n\n1. **Always edit whole top level forms** (typically `def` and `defn` and such) using the structural editing tools (`replace_top_level_form` or `insert_top_level_form`)\n2. Always check with the problem tool what the current linting state is\n3. Plan your edits, breaking it up in one edit per complete top level form you are editing or inserting\n4. With your list of edits, work backwards from the edit furthest down/nearest the end the file to the edit nearest the start of the file\n5. For each top level form in your edit plan (starting at the bottom of the file):\n   1. Edit the file using the appropriate structural editing tool\n   2. Check with the problem tool that no new problems are reported\n\n# When the bracket balance is off\n\nWhen you have a situation where e.g. the problem tool or Clojure compiler complains about missing brackets or anything suggesting the bracket balance is off:\n* Instead of going ahead trying to fix it, **use the tool for requesting human input to ask for guidance/help.**\n",
        "userDescription": "Edit Clojure files by replacing top level forms",
        "canBeReferencedInPrompt": true,
        "icon": "$(edit)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file containing the form"
            },
            "line": {
              "type": "integer",
              "description": "Line number, 1-based, where the target form/sexpression starts"
            },
            "targetLineText": {
              "type": "string",
              "description": "The exact text content (trimmed) of the line you are targeting"
            },
            "newForm": {
              "type": "string",
              "description": "The replacement form code"
            }
          },
          "required": [
            "filePath",
            "line",
            "newForm",
            "targetLineText"
          ]
        }
      },
      {
        "name": "insert_top_level_form",
        "tags": [
          "clojure",
          "editing",
          "structural-editing",
          "parinfer"
        ],
        "toolReferenceName": "insert-top-level-form",
        "displayName": "Edit: Insert Top Level Form",
        "modelDescription": "# Editing CLojure files\n\nEven as an interactive programmer, now and then you do edit files. The most important things:\n\n1. **Before any editing: First always read the whole file you are about to edit.** Instead of chunked reading, **read it in one go**.\n2. Always check with the problem tool what the current linting state is\n3. Check with the problem tool after each edit\n4. Always be alert to when the bracket balance is off, and see [When the bracket balance is off](#when-the-bracket-balance-is-off) if it is.\n\nThe specific process look different depending on if you are creating files, adding functions, or editing existing functions.\n\n## Creating Clojure files\n\nUse the `create_file` tool to create files with empty content `\"\"`.\n\n### Clojure Namespace and Filename Convention:\n\n**Important**: In Clojure,  namespace names use kebab-case while filenames use snake_case. For example:\n- Namespace: `my.project.multi-word-namespace`\n- Filename: `my/project/multi_word_namespace.clj(s|c)`\n\nAlways convert dashes in namespace names to underscores in the corresponding filename.\n\n### Create empty files, then add content\n\nFor you to create files and add content safely/predictably, follow this process:\n\n1. **Always create empty files first** - Use `create_file` with empty content `\"\"`\n2. Read the content of the file created (default content may have been added)\n3. **Use structural editing tools** to edit the file\n\n## Important about the Structural Editing Tools\n\nUse the structural editing tools for Clojure forms/s-expressions.\n\n* Use `insert_top_level_form` to add new forms to a file\n* Use `replace_top_level_form` to modify existing forms\n* Make use of the diagnostics info returned\n* **Rich Comment Forms/RCF**: Calva treats forms immediately enclosed within `(comment <like this>)` as top level forms, making them valid targets for the top_level_form editing tools.\n\nThe structural editing tools attempt to automatically balance brackets before applying edits.\n\n### `replace_top_level_form`\n* Target top level forms by their starting, 1-based, line number\n* **Important**: This tool is **only** for replacing top level Clojure one form/s-expression with another form/s-expression\n  * For editing line comments (`; ...` which are not structural), use your built in edit tools\n\n### `insert_top_level_form`\n* Always target the top level of the code\n* Use 1-based, line numbers\n* **Important**: This tool is **only** for inserting Clojure forms/s-expressions, one at a time\n  * For inserting line comments (`; ...` which are not structural), use your built in edit tool\n\n## Structural editing process\n\nFollow this process for making safe and working updates:\n\n1. **Always edit whole top level forms** (typically `def` and `defn` and such) using the structural editing tools (`replace_top_level_form` or `insert_top_level_form`)\n2. Always check with the problem tool what the current linting state is\n3. Plan your edits, breaking it up in one edit per complete top level form you are editing or inserting\n4. With your list of edits, work backwards from the edit furthest down/nearest the end the file to the edit nearest the start of the file\n5. For each top level form in your edit plan (starting at the bottom of the file):\n   1. Edit the file using the appropriate structural editing tool\n   2. Check with the problem tool that no new problems are reported\n\n# When the bracket balance is off\n\nWhen you have a situation where e.g. the problem tool or Clojure compiler complains about missing brackets or anything suggesting the bracket balance is off:\n* Instead of going ahead trying to fix it, **use the tool for requesting human input to ask for guidance/help.**\n",
        "userDescription": "Edit Clojure files by replacing top level forms",
        "canBeReferencedInPrompt": true,
        "icon": "$(edit)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file containing the form"
            },
            "line": {
              "type": "integer",
              "description": "Line number, 1-based, where to insert the form. The code will be inserted at the start of the line."
            },
            "targetLineText": {
              "type": "string",
              "description": "The exact text content (trimmed) of the line you are targeting."
            },
            "newForm": {
              "type": "string",
              "description": "The replacement form code. The code will be inserted at the start of the line."
            }
          },
          "required": [
            "filePath",
            "line",
            "newForm",
            "targetLineText"
          ]
        }
      },
      {
        "name": "request_human_input",
        "tags": [
          "information",
          "knowledge",
          "lookup"
        ],
        "toolReferenceName": "human-intelligence",
        "displayName": "Human Intelligence",
        "modelDescription": "Ask the human developer for input or guidance. Give your question context in the chat, then use this tool to request input from the human.\n\n## When to use\n* Need to think about a thing together with someone?\n* Would you benefit from clarification?\n* Is there some domain knowledge you need?\n* Have you encountered unexpected results?\n* Has the human requested to be kept in the loop?\n\n## Tool flow\nAI Agent Working → Agent Needs Input → Agents Explains Context in Chat → Calls Tool → VS Code Input Box → Human Responds → AI Continues, better informed.",
        "userDescription": "The AI asks the human developer for input or guidance",
        "canBeReferencedInPrompt": true,
        "icon": "$(person)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "The question to ask the human. First provide context in the chat, this prompt is for framing the question."
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "scripts": {
    "clean": "rimraf .cpcache .shadow-cljs/ out/ dist/",
    "preclean": "npm install",
    "watch": "clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"1.3.1\"},cider/cider-nrepl {:mvn/version,\"0.52.1\"}}}' -M -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware shadow.cljs.devtools.server.nrepl/middleware]\"",
    "test": "node out/extension-tests.js",
    "pretest": "npm run compile",
    "prewatch": "npm run clean",
    "compile": "npx shadow-cljs compile :extension :test-compile :stdio-wrapper",
    "precompile": "npm run clean",
    "release-test": "node out/extension-tests.js",
    "release": "npx shadow-cljs release :extension :test-compile :stdio-wrapper",
    "package": "npx vsce package --githubBranch master",
    "vscode:prepublish": "npm run clean && npm run release"
  },
  "dependencies": {
    "@vscode/codicons": "^0.0.36",
    "parinfer": "^3.13.1"
  },
  "devDependencies": {
    "@types/node": "^22.14.1",
    "@types/vscode": "^1.96.2",
    "@vscode/test-electron": "~2.5.2",
    "@vscode/vsce": "^3.3.2",
    "ovsx": "~0.10.1",
    "rimraf": "^6.0.1",
    "shadow-cljs": "2.28.23"
  },
  "extensionDependencies": [
    "betterthantomorrow.calva"
  ]
}
