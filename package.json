{
  "name": "calva-backseat-driver",
  "displayName": "Calva Backseat Driver",
  "description": "Make CoPilot an Interactive Programmer, tools for VS Code CoPilot. Can also be run as an MCP server",
  "version": "0.0.20",
  "publisher": "betterthantomorrow",
  "author": {
    "name": "Better Than Tomorrow",
    "email": "pez@pezius.com"
  },
  "icon": "assets/extension-icon-128x128.png",
  "repository": {
    "type": "git",
    "url": "https://github.com/BetterThanTomorrow/calva-backseat-driver.git"
  },
  "engines": {
    "vscode": ">=1.96.2",
    "node": ">=20.18.0"
  },
  "enabledApiProposals": [
    "extensionRuntime"
  ],
  "categories": [
    "Programming Languages",
    "AI",
    "Other"
  ],
  "keywords": [
    "clojure",
    "clojurescript",
    "mcp",
    "model-context-protocol",
    "ai"
  ],
  "activationEvents": [
    "onLanguage:clojure"
  ],
  "main": "out/extension.js",
  "contributes": {
    "configuration": {
      "title": "Calva Backseat Driver",
      "properties": {
        "calva-backseat-driver.enableMcpReplEvaluation": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Enable the REPL evaluation tool through MCP.\n\n **⚠️ SECURITY WARNING**: _When enabled and you have also started the MCP server, any network client with access to the MCP server can execute arbitrary code in your REPL environment._ That said, CoPilot and other compliant MCP clients will default to a low-trust mode with confirmation before any evaluation.",
          "scope": "resource"
        },
        "calva-backseat-driver.autoStartMCPServer": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Automatically start the MCP server when the extension is activated.",
          "scope": "resource"
        },
        "calva-backseat-driver.mcpSocketServerPort": {
          "type": "number",
          "default": 1664,
          "markdownDescription": "Port to start the socket server on. Use `0` to let the server choose a high available port.",
          "scope": "resource"
        }
      }
    },
    "commands": [
      {
        "command": "calva-backseat-driver.startMcpServer",
        "category": "Calva Backseat Driver",
        "enablement": "!:calva-backseat-driver/started?",
        "title": "Start the MCP socket server"
      },
      {
        "command": "calva-backseat-driver.stopMcpServer",
        "category": "Calva Backseat Driver",
        "enablement": ":calva-backseat-driver/started?",
        "title": "Stop the MCP socket server"
      },
      {
        "command": "calva-backseat-driver.openLogFile",
        "category": "Calva Backseat Driver",
        "title": "Open log file"
      }
    ],
    "keybindings": [],
    "languageModelTools": [
      {
        "name": "evaluate_clojure_code",
        "tags": [
          "clojure",
          "repl",
          "needs-connected-repl",
          "interactive-programming",
          "repl-driven-development"
        ],
        "toolReferenceName": "evaluate",
        "displayName": "Evaluate Clojure Code",
        "modelDescription": "Evaluate code using Calva's REPL connection. Enables AI Interactive Programming. Use this to make sure your edits work as you advertise, before applying them. The REPL holds the truth!\n\nEvaluating ClojureScript code?\n* remember to use the `\"cljs\"` `replSessionKey`\n* The user namespace is probably/often `cljs.user`\n* `js-keys` is a handy function to explore JS objects with",
        "userDescription": "Evaluate Clojure or ClojureScript code in the connected REPL.",
        "canBeReferencedInPrompt": true,
        "icon": "$(terminal-bash)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Code to evaluate"
            },
            "namespace": {
              "type": "string",
              "description": "Fully qualified namespace in which to evaluate the code. E.g. if calling functions in a file you are reading, it is probably the namespace of that file that should be provided. If it is the first time you use a namespace, start with evaluating its ns-form in the `user` or `cljs.user` namespace (as appropriate)."
            },
            "replSessionKey": {
              "type": "string",
              "description": "The Calva REPL session to evaluate the code via. It should be:\n* `clj` for the Clojure REPL\n* `cljs` for the ClojureScript REPL",
              "enum": [
                "clj",
                "cljs",
                "cljc"
              ]
            }
          },
          "required": [
            "code",
            "namespace",
            "replSessionKey"
          ]
        }
      },
      {
        "name": "get_symbol_info",
        "tags": [
          "clojure",
          "documentation",
          "needs-connected-repl",
          "argument-list",
          "return-values",
          "side-effects"
        ],
        "toolReferenceName": "clojure-symbol",
        "displayName": "Clojure Symbol Info",
        "modelDescription": "Get detailed information about a Clojure symbol from the connected REPL.",
        "userDescription": "Look up documentation for a Clojure symbol.",
        "canBeReferencedInPrompt": true,
        "icon": "$(tag)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clojureSymbol": {
              "type": "string",
              "description": "The symbol to look up info for"
            },
            "namespace": {
              "type": "string",
              "description": "Fully qualified namespace in which to evaluate the code. E.g. if calling functions in a file you are reading, it is probably the namespace of that file that should be provided."
            },
            "replSessionKey": {
              "type": "string",
              "description": "The Calva REPL session to evaluate the code in. For Clojure, ClojureScript, and Common, respectively. Often the same as the extension of the file you are working with. One of `clj`, `cljs`, or `cljc`.",
              "enum": [
                "clj",
                "cljs",
                "cljc"
              ]
            }
          },
          "required": [
            "clojureSymbol",
            "namespace",
            "replSessionKey"
          ]
        }
      },
      {
        "name": "get_clojuredocs_info",
        "tags": [
          "clojure",
          "clojure-core",
          "needs-connected-repl",
          "examples",
          "see-also",
          "documentation"
        ],
        "toolReferenceName": "clojuredocs",
        "displayName": "clojuredocs.org Lookup",
        "modelDescription": "Look up information, examples, see also:s, and more about a Clojure Core symbol from clojuredocs.org.",
        "userDescription": "Get examples and usage from clojuredocs.org",
        "canBeReferencedInPrompt": true,
        "icon": "$(globe)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clojureSymbol": {
              "type": "string",
              "description": "The symbol to look up on clojuredocs.org"
            }
          },
          "required": [
            "clojureSymbol"
          ]
        }
      },
      {
        "name": "get_repl_output_log",
        "tags": [
          "clojure",
          "repl",
          "evaluation-results",
          "stdout",
          "stderr"
        ],
        "toolReferenceName": "calva-output",
        "displayName": "Calva REPL Output Log",
        "modelDescription": "Get REPL output messages from  Calva output window. Returns REPL output since `since-line`. Start with since-line=0 and use the last line number from previous output for subsequent calls. This is your window into the running application. Invoke it often as files are edited and/or you evaluate code.",
        "userDescription": "Read Calva's REPL output log",
        "canBeReferencedInPrompt": true,
        "icon": "$(list-ordered)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sinceLine": {
              "type": "integer",
              "description": "Output line-number after which you want output. Use `0` for your first request of output."
            }
          },
          "required": [
            "sinceLine"
          ]
        }
      },
      {
        "name": "clojure_balance_brackets",
        "tags": [
          "clojure",
          "parinfer",
          "brackets",
          "balance",
          "structural-editing"
        ],
        "toolReferenceName": "balance-brackets",
        "displayName": "Bracket Balancer",
        "modelDescription": "This tool AUTHORITATIVELY balances brackets in Clojure code. Always follow these steps when using it:\n\n1. Pass the COMPLETE content of the file or would-be file without any modifications\n2. Use the EXACT output from this tool to replace the ENTIRE file content\n3. NEVER modify the tool's output or analyze its changes",
        "userDescription": "Balance brackets in Clojure code",
        "canBeReferencedInPrompt": true,
        "icon": "$(bracket-error)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The COMPLETE text of the file needing bracket balancing. Do not modify this text in any way before passing it to the tool."
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "replace_top_level_form",
        "tags": [
          "clojure",
          "editing",
          "structural-editing",
          "parinfer"
        ],
        "toolReferenceName": "replace-top-level-form",
        "displayName": "Edit: Replace Top Level Form",
        "modelDescription": "This is the **Replace Top Level Form** tool. Use it to modify an existing top level form. To delete a top level form, replace it with an empty string.\n\n**Important**: This tool is **only** for replacing Clojure forms/s-expressions, **one at a time**\n* For editing line comments (`; ...` which are not structural), use the built in edit tool\n\nProcess:\n\n1. Find the top level form you want to replace.\n2. Read the first line of the form and use the text for the `targetLineText` param\n3. Use the 1-based line number for the `line` param\n\n# Editing Clojure files\n\nWe refer to all files of reasonably Clojure-ish type as **Clojure files**, be it Clojure, ClojureScript, Babashka, nbb, Joyride, Jank, you-name-it.\n\nEven as an interactive programmer, now and then you do edit files.\n\n* The structural editing tools attempt to automatically balance brackets before applying edits.\n* The tools return post-edit diagnostics/linting info. Make use of it!\n\nThe specific processes look different depending on if you are creating files, appending forms, inserting forms, or editing existing forms.\n\n## Code Indentation Before REPL Evaluation\n\n**Always ensure that Clojure code is properly indented.** Proper indentation is essential for the structural editing tools to work correctly.\n\n### Essential Rule:\n- **Indent code properly** - Align nested forms with consistent indentation before evaluation\n\n### Pattern:\n```clojure\n;; ❌ Poor indentation - will cause issues\n(defn my-function [x]\n  {:foo 1\n  :bar 2}) ; `:bar` is not properly “inside” the enclosing map\n\n;; ✅ Proper indentation - ready for use with the structural editing tools\n(defn my-function [x]\n  {:foo 1\n   :bar 2}) ; `:bar` is properly “inside” the enclosing map\n```\n\n## When the bracket balance is off\n\nWhen you have a situation where e.g. the problem tool or Clojure compiler complains about missing brackets or anything suggesting the bracket balance is off (probably because you have used non-structural editing tools):\n* Instead of going ahead trying to fix it, **use the tool for requesting human input to ask for guidance/help.**\n\n## About top level forms\n\nThe structural editing tools appends/inserts/replaces top level forms/s-expressions, such as the `ns` form, `def`, `defn`, `def...` forms, and many Rich Comment Forms. Top level form is Calva nomenclature for referring to forms at the root/top level of the Clojure code structure.\n\n**Rich Comment Forms/RCF**: Calva treats forms immediately enclosed within `(comment <like this>)` as top level forms, making them valid targets for the top_level_form editing tools. (The `(comment ... )` form itself is also a top level form, as far as Calva and the tools are concerned.)\n\n## Structural editing process\n\nFollow this process for making safe and working updates:\n\n1. **Always edit whole top level forms** (typically `ns`, `def` and `defn` and such) using the structural editing tools (**Replace Top Level Form** or **Insert Top Level Form** )\n2. Always check with the problem tool what the current linting state is\n3. If you are doing multiple edits to a file: **Plan your edits**, breaking it up in one edit per complete top level form you are editing or inserting. Use the todo list.\n   - **Work from bottom to top of the file** - Because editing tools use line numbers, and edits can shift line numbers of content below them, always apply your edits starting from the lowest line number (bottom of file) and work upward. This keeps your planned line numbers accurate.\n\n     Example: If you plan to edit lines 10, 20, and 30, edit them in this order: line 30 → line 20 → line 10.\n\n     1. For each top level form in your edit plan (starting at the bottom of the file):\n        * Edit the file using the appropriate structural editing tool\n\n    Remember that in Clojure, functions need to be defined before they are called, so during the edits this way, linter complaints about symbols not found are to be expected. When the edit plan is carried out, you should have no new such warnings.\n\n",
        "userDescription": "Edit Clojure files by replacing top level forms",
        "canBeReferencedInPrompt": true,
        "icon": "$(edit)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file containing the form"
            },
            "line": {
              "type": "integer",
              "description": "The target line number, 1-based, where the target top level form/sexpression starts."
            },
            "targetLineText": {
              "type": "string",
              "description": "The exact text content of the line you are targeting. This is the text from the first line of the target top level form."
            },
            "newForm": {
              "type": "string",
              "description": "The replacement form code"
            }
          },
          "required": [
            "filePath",
            "line",
            "newForm",
            "targetLineText"
          ]
        }
      },
      {
        "name": "insert_top_level_form",
        "tags": [
          "clojure",
          "editing",
          "structural-editing",
          "parinfer"
        ],
        "toolReferenceName": "insert-top-level-form",
        "displayName": "Edit: Insert Top Level Form",
        "modelDescription": "This is the **Insert Top Level Form** tool. Use it to insert new forms to a file, the forms will be inserted before an existing, targeted, top level form.\n\n**Important**: This tool is **only** for inserting Clojure forms/s-expressions\n* For inserting line comments (`; ...` which are not structural), use your built in edit tool\n\nProcess:\n\n1. Find the top level form you want to insert code before.\n2. Read the first line of the form and use the text for the `targetLineText` param\n3. Use the 1-based line number for the `line` param\n\n# Editing Clojure files\n\nWe refer to all files of reasonably Clojure-ish type as **Clojure files**, be it Clojure, ClojureScript, Babashka, nbb, Joyride, Jank, you-name-it.\n\nEven as an interactive programmer, now and then you do edit files.\n\n* The structural editing tools attempt to automatically balance brackets before applying edits.\n* The tools return post-edit diagnostics/linting info. Make use of it!\n\nThe specific processes look different depending on if you are creating files, appending forms, inserting forms, or editing existing forms.\n\n## Code Indentation Before REPL Evaluation\n\n**Always ensure that Clojure code is properly indented.** Proper indentation is essential for the structural editing tools to work correctly.\n\n### Essential Rule:\n- **Indent code properly** - Align nested forms with consistent indentation before evaluation\n\n### Pattern:\n```clojure\n;; ❌ Poor indentation - will cause issues\n(defn my-function [x]\n  {:foo 1\n  :bar 2}) ; `:bar` is not properly “inside” the enclosing map\n\n;; ✅ Proper indentation - ready for use with the structural editing tools\n(defn my-function [x]\n  {:foo 1\n   :bar 2}) ; `:bar` is properly “inside” the enclosing map\n```\n\n## When the bracket balance is off\n\nWhen you have a situation where e.g. the problem tool or Clojure compiler complains about missing brackets or anything suggesting the bracket balance is off (probably because you have used non-structural editing tools):\n* Instead of going ahead trying to fix it, **use the tool for requesting human input to ask for guidance/help.**\n\n## About top level forms\n\nThe structural editing tools appends/inserts/replaces top level forms/s-expressions, such as the `ns` form, `def`, `defn`, `def...` forms, and many Rich Comment Forms. Top level form is Calva nomenclature for referring to forms at the root/top level of the Clojure code structure.\n\n**Rich Comment Forms/RCF**: Calva treats forms immediately enclosed within `(comment <like this>)` as top level forms, making them valid targets for the top_level_form editing tools. (The `(comment ... )` form itself is also a top level form, as far as Calva and the tools are concerned.)\n\n## Structural editing process\n\nFollow this process for making safe and working updates:\n\n1. **Always edit whole top level forms** (typically `ns`, `def` and `defn` and such) using the structural editing tools (**Replace Top Level Form** or **Insert Top Level Form** )\n2. Always check with the problem tool what the current linting state is\n3. If you are doing multiple edits to a file: **Plan your edits**, breaking it up in one edit per complete top level form you are editing or inserting. Use the todo list.\n   - **Work from bottom to top of the file** - Because editing tools use line numbers, and edits can shift line numbers of content below them, always apply your edits starting from the lowest line number (bottom of file) and work upward. This keeps your planned line numbers accurate.\n\n     Example: If you plan to edit lines 10, 20, and 30, edit them in this order: line 30 → line 20 → line 10.\n\n     1. For each top level form in your edit plan (starting at the bottom of the file):\n        * Edit the file using the appropriate structural editing tool\n\n    Remember that in Clojure, functions need to be defined before they are called, so during the edits this way, linter complaints about symbols not found are to be expected. When the edit plan is carried out, you should have no new such warnings.\n\n",
        "userDescription": "Edit Clojure files by replacing top level forms",
        "canBeReferencedInPrompt": true,
        "icon": "$(edit)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file containing the form"
            },
            "line": {
              "type": "integer",
              "description": "The target line number, 1-based, where the target top level form/sexpression starts. The code will be inserted at the start of the line."
            },
            "targetLineText": {
              "type": "string",
              "description": "The exact text content of the line you are targeting. This is the text from the first line of the target top level form."
            },
            "newForm": {
              "type": "string",
              "description": "The replacement form code. The code will be inserted at the start of the line."
            }
          },
          "required": [
            "filePath",
            "line",
            "newForm",
            "targetLineText"
          ]
        }
      },
      {
        "name": "request_human_input",
        "tags": [
          "information",
          "knowledge",
          "lookup"
        ],
        "toolReferenceName": "human-intelligence",
        "displayName": "Human Intelligence",
        "modelDescription": "Ask the human developer for input or guidance. Give your question context in the chat, then use this tool to request input from the human.\n\n## When to use\n* Need to think about a thing together with someone?\n* Would you benefit from clarification?\n* Is there some domain knowledge you need?\n* Have you encountered unexpected results?\n* Has the human requested to be kept in the loop?\n\n## Tool flow\nAI Agent Working → Agent Needs Input → Agents Explains Context in Chat → Calls Tool → VS Code Input Box → Human Responds → AI Continues, better informed.",
        "userDescription": "The AI asks the human developer for input or guidance",
        "canBeReferencedInPrompt": true,
        "icon": "$(person)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "The question to ask the human. First provide context in the chat, this prompt is for framing the question."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "clojure_create_file",
        "tags": [
          "clojure",
          "file-creation",
          "structural-editing"
        ],
        "toolReferenceName": "clojure-create-file",
        "displayName": "Create Clojure File",
        "modelDescription": "This is the **Create Clojure File** tool. Use it to create a Clojure file. Create the file with all the content you know should go there at the time of creation.\n\n## Clojure Namespace and Filename Convention:\n\n**Important**: In Clojure, namespace names use kebab-case while filenames use snake_case. For example:\n- Namespace: `my.project.multi-word-namespace`\n- Filename: `my/project/multi_word_namespace.clj(s|c)`\n\nAlways convert dashes in namespace names to underscores in the corresponding filename.\n\n## Use structural editing tools\n\nOnce the file is created and you need to append/insert/replace forms in it, use the appropriate structural editing tool for that.\n\n# Editing Clojure files\n\nWe refer to all files of reasonably Clojure-ish type as **Clojure files**, be it Clojure, ClojureScript, Babashka, nbb, Joyride, Jank, you-name-it.\n\nEven as an interactive programmer, now and then you do edit files.\n\n* The structural editing tools attempt to automatically balance brackets before applying edits.\n* The tools return post-edit diagnostics/linting info. Make use of it!\n\nThe specific processes look different depending on if you are creating files, appending forms, inserting forms, or editing existing forms.\n\n## Code Indentation Before REPL Evaluation\n\n**Always ensure that Clojure code is properly indented.** Proper indentation is essential for the structural editing tools to work correctly.\n\n### Essential Rule:\n- **Indent code properly** - Align nested forms with consistent indentation before evaluation\n\n### Pattern:\n```clojure\n;; ❌ Poor indentation - will cause issues\n(defn my-function [x]\n  {:foo 1\n  :bar 2}) ; `:bar` is not properly “inside” the enclosing map\n\n;; ✅ Proper indentation - ready for use with the structural editing tools\n(defn my-function [x]\n  {:foo 1\n   :bar 2}) ; `:bar` is properly “inside” the enclosing map\n```\n",
        "userDescription": "Create a new Clojure file",
        "canBeReferencedInPrompt": true,
        "icon": "$(file-add)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path where the file should be created"
            },
            "content": {
              "type": "string",
              "description": "The content to write to the file"
            }
          },
          "required": [
            "filePath",
            "content"
          ]
        }
      },
      {
        "name": "clojure_append_code",
        "tags": [
          "clojure",
          "code-editing",
          "structural-editing"
        ],
        "toolReferenceName": "append-code",
        "displayName": "Append Code",
        "modelDescription": "This is the **Append Code** tool. Use it to append top level forms at the end of a Clojure file.\n\n# Editing Clojure files\n\nWe refer to all files of reasonably Clojure-ish type as **Clojure files**, be it Clojure, ClojureScript, Babashka, nbb, Joyride, Jank, you-name-it.\n\nEven as an interactive programmer, now and then you do edit files.\n\n* The structural editing tools attempt to automatically balance brackets before applying edits.\n* The tools return post-edit diagnostics/linting info. Make use of it!\n\nThe specific processes look different depending on if you are creating files, appending forms, inserting forms, or editing existing forms.\n\n## Code Indentation Before REPL Evaluation\n\n**Always ensure that Clojure code is properly indented.** Proper indentation is essential for the structural editing tools to work correctly.\n\n### Essential Rule:\n- **Indent code properly** - Align nested forms with consistent indentation before evaluation\n\n### Pattern:\n```clojure\n;; ❌ Poor indentation - will cause issues\n(defn my-function [x]\n  {:foo 1\n  :bar 2}) ; `:bar` is not properly “inside” the enclosing map\n\n;; ✅ Proper indentation - ready for use with the structural editing tools\n(defn my-function [x]\n  {:foo 1\n   :bar 2}) ; `:bar` is properly “inside” the enclosing map\n```\n",
        "userDescription": "Append code to the end of a Clojure file",
        "canBeReferencedInPrompt": true,
        "icon": "$(add)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file to append to"
            },
            "code": {
              "type": "string",
              "description": "The code forms to append to the file"
            }
          },
          "required": [
            "filePath",
            "code"
          ]
        }
      }
    ]
  },
  "scripts": {
    "clean": "rimraf .cpcache .shadow-cljs/ out/ dist/",
    "preclean": "npm install",
    "watch": "clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"1.3.1\"},cider/cider-nrepl {:mvn/version,\"0.52.1\"}}}' -M -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware shadow.cljs.devtools.server.nrepl/middleware]\"",
    "test": "node out/extension-tests.js",
    "pretest": "npm run compile",
    "prewatch": "npm run clean",
    "compile": "npx shadow-cljs compile :extension :test-compile :stdio-wrapper",
    "precompile": "npm run clean",
    "release-test": "node out/extension-tests.js",
    "release": "npx shadow-cljs release :extension :test-compile :stdio-wrapper",
    "package": "npx vsce package --githubBranch master",
    "vscode:prepublish": "npm run clean && npm run release"
  },
  "dependencies": {
    "@vscode/codicons": "^0.0.36",
    "parinfer": "^3.13.1"
  },
  "devDependencies": {
    "@types/node": "^22.14.1",
    "@types/vscode": "^1.96.2",
    "@vscode/test-electron": "~2.5.2",
    "@vscode/vsce": "^3.3.2",
    "ovsx": "~0.10.1",
    "rimraf": "^6.0.1",
    "shadow-cljs": "2.28.23"
  },
  "extensionDependencies": [
    "betterthantomorrow.calva"
  ]
}
